#! /usr/bin/env python
# -*- coding: utf-8 -*-
'''Simulate tree'''
import os
from nestly import Nest
from nestly.scons import SConsWrap
# the following must be exported by parent SConstruct/SConscript
Import('env tool_dict quick idlabel outdir naive mutability substitution lambda_list lambda0_list n N T nsim CommandRunner experimental_list naiveIDexp selection_param xarg buffarg')

nest = Nest()
w = SConsWrap(nest, outdir, alias_environment=env)

w.add_aggregate('outeragg', list) # <-- aggregating results across parameters

# Initialize our first nest level,
w.add('lambda', lambda_list)
w.add('lambda0', lambda0_list)
w.add_aggregate('agg', list) # <-- for aggregating inference result from repeated simulations with the same parameters
w.add_aggregate('simstat_agg', list) # <-- for aggregating simulation stats with the same parameters
w.add_aggregate('summary_stats', list) # <-- summary stats for CFT study (no abundance)

# next nest, just random simulation reruns, same params
w.add('runs', range(1, nsim+1))

@w.add_target()
def gc_sim(outdir, c):
    '''
    GCtree simulation
    NOTE: xvfb-run is needed because of issue https://github.com/etetoolkit/ete/issues/101
    '''
    idlabel_arg = ' --idlabel' if idlabel else ''
    T_arg = ' --T {} '.format(' '.join(map(str, T))) if T else ''
    N_arg = ' --N {} '.format(N) if N is not None else ''
    n_arg = ' --n {} '.format(n) if n is not None else ''
    sele_arg = ' --selection --target_dist {} --target_count {} --carry_cap {} --skip_update {} {}'.format(*selection_param) if selection_param is not None else ''
    tgt = CommandRunner([os.path.join(outdir, 'GCsim.fasta'),
                         os.path.join(outdir, 'GCsim_stats.tsv'),
                         os.path.join(outdir, 'GCsim_collapsed_tree.p'),
                         os.path.join(outdir, 'GCsim_collapsed_tree_colormap.tsv'),
                         os.path.join(outdir, 'simulator.log')],
                        [mutability, substitution],
                        xarg + buffarg + 'python bin/simulator.py --sequence '+naive+
                        ' --mutability ${SOURCES[0]} --substitution ${SOURCES[1]}'+
                        ' --outbase '+os.path.join(outdir, 'GCsim')+
                        ' --lambda {0[lambda]} --lambda0 {0[lambda0]}'.format(c)+
                        idlabel_arg+
                        T_arg+
                        N_arg+
                        n_arg+
                        sele_arg+
                        ' > ${TARGETS[4]}')
    c['simstat_agg'].append(tgt[1])
    c['summary_stats'].append(tgt[0])
    return tgt

@w.add_target()
def infer(outdir, c):
    '''now do inference on the simulation results'''
    fasta = c['gc_sim'][0]
    fasta2 = None
    naiveID = 'naive' # this is what the simulation routine names the naive
    converter = None  # No problem with weird fasta formating from the simulated data
    colorfile = None
    return SConscript('SConscript.inference', exports='env tool_dict quick idlabel fasta fasta2 outdir naiveID converter CommandRunner xarg buffarg colorfile')

@w.add_target()
def validate(outdir, c):
    '''do validation'''
    outputs = [os.path.join(outdir, 'validation.tsv'), # <-- this one compares different methods
               os.path.join(outdir, 'validation.log')]
    if tool_dict['gctree']:
        outputs.append(os.path.join(outdir, 'validation_gctree.tsv')) # <-- special gctree output evaluating parsimony tree ranking
    tgt = CommandRunner(outputs,
                   [c['gc_sim'][2:4]] + [x[0] for x in c['infer']],
                    xarg + buffarg + 'python bin/validation.py $SOURCES --outbase '+os.path.join(outdir, 'validation')+' > ${TARGETS[1]}')
    c['agg'].append(tgt[0])
    return tgt

w.pop('runs')


@w.add_target()
def simstat_aggregate(outdir, c):
    '''aggregate simulation stats'''
    tgt = env.Command([os.path.join(outdir, 'simulation_stats.log')],
                      c['simstat_agg'],
                      buffarg + 'python bin/simstatagg.py $SOURCES --outbase '+os.path.join(outdir, 'simulation.stats')+
                      ' --experimental Victora_data/150228_Clone_3-8.fasta > ${TARGETS[0]}')
    env.AlwaysBuild(tgt)
    return tgt

@w.add_target()
def summary_stats(outdir, c):
    '''aggregate simulation stats CFT version'''
    exp_arg = ' --experimental ' + ' '.join(experimental_list) if len(experimental_list) > 0 else ''
    tgt = env.Command([os.path.join(outdir, 'simulation_summary_stats.log')],
                      c['summary_stats'],
                      buffarg + 'python bin/summary_stats.py $SOURCES --outbase '+os.path.join(outdir, 'simulation_summary_stats')+
                      exp_arg +
                      ' --naiveIDexp ' + naiveIDexp + ' > ${TARGETS[0]}')
    env.AlwaysBuild(tgt)
    return tgt

@w.add_target()
def inner_aggregate(outdir, c):
    '''aggregate validation results'''
    tgt = env.Command([os.path.join(outdir, 'validaggreg.tsv'),
                       os.path.join(outdir, 'validaggreg.log')],
                      c['agg'],
                      buffarg + 'python bin/validaggreg_compare.py $SOURCES --outbase '+os.path.join(outdir, 'validaggreg')+' > ${TARGETS[1]}')
    env.AlwaysBuild(tgt)
    c['outeragg'].append(tgt[0])
    return tgt

w.pop('lambda')

@w.add_target()
def outer_aggregate(outdir, c):
    '''aggregate different parameter values'''
    tgt = env.Command([os.path.join(outdir, 'aggregation.tsv'),
                       os.path.join(outdir, 'aggregation.log')],
                      c['outeragg'],
                      buffarg + 'python bin/aggregate_compare.py $SOURCES --outbase '+os.path.join(outdir, 'aggregation')+' > ${TARGETS[1]}')
    env.AlwaysBuild(tgt)
    return tgt
